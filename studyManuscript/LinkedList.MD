[使用markdown方法](https://www.cnblogs.com/liugang-vip/p/6337580.html) 

# 链表（LinkedList）
-----
 * 链表的应用场景：
 > 缓存是一种应用于快速存储、读取数据的一种数据保存方式，应用于各个场景中，由于缓存大小有限，我们需要知道哪些缓存重的数据可以在清理缓存的过程中保留，
 哪些可以清除，这就涉及到了缓存的淘汰策略（也就是我们说的缓存淘汰算法），其中CPU缓存、浏览器缓存、数据库缓存经常会用到缓存淘汰策略（算法），经常看到的
 缓存淘汰策略包括：_FIFO（First In, First Out），LFU（Least Frequently Used），LRU（Least Recently Used）_
 
 * 链表与数组的区别：
 >链表在缓存中**离散分布的内存空间**，而数组是一块**连续的内存空间**，同样是申请100M内存空间，如果在内存中没有连续的100M内存空间，数组申请会失败，而链表
 不会，比较常用的链表结构有三种：_单链表（Singly LinkedList），循环链表（Circle LinkedList），双向链表（Doubly LinkedList）_
 
## 单链表（Singly LinkedList）
-----
>单链表结构，很简单包含数据和下一个节点的指针（java中即下一个节点的内存地址）和数组一样，单链表也有插入、删除操作，时间复杂度为O(1)，但是单链表的随机访问数据
的时间复杂度就很一般了为O(n)，单链表的结尾节点地址指针为null表示尾节点，需要注意的是单单插入、删除操作的时间复杂度为O(1)，但是在插入、删除的时候需要先查询需要
删除节点的位置，因此插入、删除总的时间复杂度为O(n) 即总的时间复杂度为查询O(n)+删除O(1) = O(n)

## 循环链表（Circle LinkedList）
-----
>循环列表就是在单链表的基础上对最后一个节点的指针指向头节点，其余的查询操作时间复杂度和删除、插入时间复杂度一样，遇到相似的应用场景时使用即可。

## 双向链表（Doubly LinkedList）
-----
>代码实现方法可以参考LinkedHashMap，相比于单链表多了反向指针，在存储空间上开销比较大，但是查找在特定条件下会比理论上O(n)的链表查找效率要高，比如：在删除指定节点
的时候，单链表在删除时需要本身要删除的节点删除之外还需要将前置节点的指针指向删除节点下一个节点的地址，因为是单链表没有反向的指针，此时他的删除操作总的时间复杂度就是O(n)
，相比之下双向链表的优势就体现出来了，双向链表因为有反向指针，在删除本身节点的时候可以通过反向指针删除之前的和之后的节点，因此双向链表的删除操作时间复杂度就是O(1)；

与链表相关几个典型算法：
LRU算法，Palindrome算法，Josephus problem --单链表

链表本身操作需要实践的方法：
链表反转、有序链表合并、链表中环检测、删除链表倒数第n个节点、求链表的中间节点
LeetCode对应编号：206，141，21，19，876

链表代码实现需要注意的几点：



 